{"ast":null,"code":"export let TileType=/*#__PURE__*/function(TileType){TileType[\"WAN\"]=\"wan\";// 万\nTileType[\"TIAO\"]=\"tiao\";// 条\nTileType[\"TONG\"]=\"tong\";// 筒\nTileType[\"ZI\"]=\"zi\";// 字牌\nreturn TileType;}({});export let MeldType=/*#__PURE__*/function(MeldType){MeldType[\"PENG\"]=\"peng\";// 碰\nMeldType[\"GANG\"]=\"gang\";// 杠\nMeldType[\"CHI\"]=\"chi\";// 吃\nreturn MeldType;}({});export let GangType=/*#__PURE__*/function(GangType){GangType[\"MING_GANG\"]=\"ming_gang\";// 明杠（直杠）\nGangType[\"AN_GANG\"]=\"an_gang\";// 暗杠\nGangType[\"JIA_GANG\"]=\"jia_gang\";// 加杠\nreturn GangType;}({});// 输入模式枚举\nexport let InputMode=/*#__PURE__*/function(InputMode){InputMode[\"ADD_TO_HAND\"]=\"add_to_hand\";InputMode[\"DISCARD\"]=\"discard\";InputMode[\"PENG\"]=\"peng\";InputMode[\"MING_GANG\"]=\"ming_gang\";InputMode[\"AN_GANG\"]=\"an_gang\";return InputMode;}({});// 工具函数\nexport const createTile=(type,value)=>({type,value});export const tileToCode=tile=>{switch(tile.type){case TileType.WAN:return tile.value;case TileType.TIAO:return tile.value+10;case TileType.TONG:return tile.value+20;case TileType.ZI:return tile.value+30;default:throw new Error(\"Invalid tile type: \".concat(tile.type));}};export const codeToTile=code=>{if(1<=code&&code<=9){return{type:TileType.WAN,value:code};}else if(11<=code&&code<=19){return{type:TileType.TIAO,value:code-10};}else if(21<=code&&code<=29){return{type:TileType.TONG,value:code-20};}else if(31<=code&&code<=37){return{type:TileType.ZI,value:code-30};}else{throw new Error(\"Invalid tile code: \".concat(code));}};export const tileToString=tile=>{const typeMap={[TileType.WAN]:\"万\",[TileType.TIAO]:\"条\",[TileType.TONG]:\"筒\",[TileType.ZI]:[\"\",\"东\",\"南\",\"西\",\"北\",\"中\",\"发\",\"白\"][tile.value]||\"\"};if(tile.type===TileType.ZI){return typeMap[tile.type];}else{return\"\".concat(tile.value).concat(typeMap[tile.type]);}};export const tilesEqual=(tile1,tile2)=>{return tile1.type===tile2.type&&tile1.value===tile2.value;};// 计算剩余牌数\nexport const calculateRemainingTiles=gameState=>{const totalTiles=144;// 标准麻将总牌数\n// 计算已使用的牌数\nlet usedTiles=0;// 计算所有玩家手牌数量\nObject.values(gameState.player_hands).forEach(hand=>{usedTiles+=hand.tiles.length;// 计算碰牌杠牌数量\nhand.melds.forEach(meld=>{usedTiles+=meld.tiles.length;});});// 计算弃牌数量\nusedTiles+=gameState.discarded_tiles.length;return Math.max(0,totalTiles-usedTiles);};","map":{"version":3,"names":["TileType","MeldType","GangType","InputMode","createTile","type","value","tileToCode","tile","WAN","TIAO","TONG","ZI","Error","concat","codeToTile","code","tileToString","typeMap","tilesEqual","tile1","tile2","calculateRemainingTiles","gameState","totalTiles","usedTiles","Object","values","player_hands","forEach","hand","tiles","length","melds","meld","discarded_tiles","Math","max"],"sources":["D:/codes/PocketFlow-Tutorial-Codebase-Knowledge/paul/mj/frontend/src/types/mahjong.ts"],"sourcesContent":["export enum TileType {\n  WAN = \"wan\",      // 万\n  TIAO = \"tiao\",    // 条\n  TONG = \"tong\",    // 筒\n  ZI = \"zi\"         // 字牌\n}\n\nexport interface Tile {\n  type: TileType;\n  value: number;\n  id?: string;      // 添加牌的唯一标识\n}\n\nexport enum MeldType {\n  PENG = \"peng\",    // 碰\n  GANG = \"gang\",    // 杠\n  CHI = \"chi\"       // 吃\n}\n\nexport enum GangType {\n  MING_GANG = \"ming_gang\",  // 明杠（直杠）\n  AN_GANG = \"an_gang\",      // 暗杠\n  JIA_GANG = \"jia_gang\"     // 加杠\n}\n\nexport interface Meld {\n  id?: string;      // 添加唯一标识\n  type: MeldType;\n  tiles: Tile[];\n  exposed: boolean;\n  gang_type?: GangType; // 杠牌类型（仅当type为GANG时有效）\n  source_player?: number;        // 直杠时：被杠牌的来源玩家ID\n  original_peng_id?: string;     // 加杠时：原碰牌的ID\n  timestamp?: number;            // 操作时间戳\n}\n\nexport interface HandTiles {\n  tiles: Tile[];\n  melds: Meld[];\n}\n\nexport interface PlayerAction {\n  player_id: number;\n  action_type: string;\n  tiles: Tile[];\n  timestamp?: number;\n}\n\nexport interface GameState {\n  player_hands: { [key: number]: HandTiles };\n  discarded_tiles: Tile[];\n  player_discarded_tiles?: { [key: number]: Tile[] };\n  remaining_tiles: Tile[];\n  current_player: number;\n  actions_history: PlayerAction[];\n}\n\nexport interface AnalysisResult {\n  recommended_discard?: Tile;\n  discard_scores: { [key: string]: number };\n  listen_tiles: Tile[];\n  win_probability: number;\n  remaining_tiles_count: { [key: number]: number };\n  suggestions: string[];\n}\n\nexport interface GameRequest {\n  game_state: GameState;\n  target_player: number;\n}\n\nexport interface GameResponse {\n  success: boolean;\n  analysis?: AnalysisResult;\n  message: string;\n}\n\nexport interface TileInfo {\n  code: number;\n  type: string;\n  value: number;\n  display: string;\n}\n\n// 输入模式枚举\nexport enum InputMode {\n  ADD_TO_HAND = \"add_to_hand\",\n  DISCARD = \"discard\", \n  PENG = \"peng\",\n  MING_GANG = \"ming_gang\",\n  AN_GANG = \"an_gang\"\n}\n\n// 工具函数\nexport const createTile = (type: TileType, value: number): Tile => ({\n  type,\n  value\n});\n\nexport const tileToCode = (tile: Tile): number => {\n  switch (tile.type) {\n    case TileType.WAN:\n      return tile.value;\n    case TileType.TIAO:\n      return tile.value + 10;\n    case TileType.TONG:\n      return tile.value + 20;\n    case TileType.ZI:\n      return tile.value + 30;\n    default:\n      throw new Error(`Invalid tile type: ${tile.type}`);\n  }\n};\n\nexport const codeToTile = (code: number): Tile => {\n  if (1 <= code && code <= 9) {\n    return { type: TileType.WAN, value: code };\n  } else if (11 <= code && code <= 19) {\n    return { type: TileType.TIAO, value: code - 10 };\n  } else if (21 <= code && code <= 29) {\n    return { type: TileType.TONG, value: code - 20 };\n  } else if (31 <= code && code <= 37) {\n    return { type: TileType.ZI, value: code - 30 };\n  } else {\n    throw new Error(`Invalid tile code: ${code}`);\n  }\n};\n\nexport const tileToString = (tile: Tile): string => {\n  const typeMap = {\n    [TileType.WAN]: \"万\",\n    [TileType.TIAO]: \"条\", \n    [TileType.TONG]: \"筒\",\n    [TileType.ZI]: [\"\", \"东\", \"南\", \"西\", \"北\", \"中\", \"发\", \"白\"][tile.value] || \"\"\n  };\n  \n  if (tile.type === TileType.ZI) {\n    return typeMap[tile.type];\n  } else {\n    return `${tile.value}${typeMap[tile.type]}`;\n  }\n};\n\nexport const tilesEqual = (tile1: Tile, tile2: Tile): boolean => {\n  return tile1.type === tile2.type && tile1.value === tile2.value;\n};\n\n// 计算剩余牌数\nexport const calculateRemainingTiles = (gameState: GameState): number => {\n  const totalTiles = 144; // 标准麻将总牌数\n  \n  // 计算已使用的牌数\n  let usedTiles = 0;\n  \n  // 计算所有玩家手牌数量\n  Object.values(gameState.player_hands).forEach(hand => {\n    usedTiles += hand.tiles.length;\n    // 计算碰牌杠牌数量\n    hand.melds.forEach(meld => {\n      usedTiles += meld.tiles.length;\n    });\n  });\n  \n  // 计算弃牌数量\n  usedTiles += gameState.discarded_tiles.length;\n  \n  return Math.max(0, totalTiles - usedTiles);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}